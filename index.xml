<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>小帅的技术小黑屋</title>
    <link>https://xxsvip.github.io/</link>
    <description>Recent content on 小帅的技术小黑屋</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 23 Apr 2020 11:03:53 +0800</lastBuildDate>
    
	<atom:link href="https://xxsvip.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>配套</title>
      <link>https://xxsvip.github.io/jonhon/%E9%85%8D%E5%A5%97/</link>
      <pubDate>Thu, 23 Apr 2020 11:03:53 +0800</pubDate>
      
      <guid>https://xxsvip.github.io/jonhon/%E9%85%8D%E5%A5%97/</guid>
      <description>配套是针对工作订单进行的操作。
配套在哪个系统进行，车间订单就在哪个系统生成。
目前38999车间想通过在MES中进行配套，所以接收的是ERP的工作订单，制造十部按原来的方式，在ERP中进行配套，所以接收的是ERP的车间订单。</description>
    </item>
    
    <item>
      <title>Redis</title>
      <link>https://xxsvip.github.io/docker/redis/</link>
      <pubDate>Mon, 20 Apr 2020 21:25:27 +0800</pubDate>
      
      <guid>https://xxsvip.github.io/docker/redis/</guid>
      <description>docker run -p 6379:6379 --name redis \ -v /Users/xingxiaoshuai/software/docker/redis:/data \ -v /Users/xingxiaoshuai/software/docker/redis/conf/redis.conf:/etc/redis/redis.conf \ -d redis redis-server /etc/redis/redis.conf  注意：上面的redis.conf文件要先创建了，否则会认为是一个目录
docker exec -it redis redis-cli  直接运行上面命令操作redis
默认redis是将数据存储在内存中的，在redis.conf文件中输入：
appendonly yes  这样会在redis目录下生成appendonly.aof文件，重启redis数据不会丢失。
docker update 容器名称 --restart=always  设置容器自启动。</description>
    </item>
    
    <item>
      <title>Modbus</title>
      <link>https://xxsvip.github.io/iot/modbus/</link>
      <pubDate>Fri, 17 Apr 2020 10:19:26 +0800</pubDate>
      
      <guid>https://xxsvip.github.io/iot/modbus/</guid>
      <description>数据模型 PLC地址 数据类型 读写方式 备注     Discretes Input寄存器1：离散输入 10001-19999 single bit read only This type of data can be provided by an I/O system.   Coils
寄存器0:线圈 00001-09999 single bit read-write this type of data can be alterable by an application program   Input Registers
寄存器3:输入寄存器 30001-39999 16bit word readonly this type of data can be provided by an I/O system.   Holding Registers</description>
    </item>
    
    <item>
      <title>DevTools热部署</title>
      <link>https://xxsvip.github.io/springboot/devtools%E7%83%AD%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Wed, 15 Apr 2020 17:07:07 +0800</pubDate>
      
      <guid>https://xxsvip.github.io/springboot/devtools%E7%83%AD%E9%83%A8%E7%BD%B2/</guid>
      <description> 1.pom文件引入依赖： &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-devtools&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;true&amp;lt;/scope&amp;gt; &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt; &amp;lt;/dependency&amp;gt;  2.pom插件设置： &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;fork&amp;gt;true&amp;lt;/fork&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt;  3.idea设置 到设置中 build,Execution,Deployment=&amp;gt;Compiler=&amp;gt;Build project automatically勾选上。
4.registry设置 cmd+shift+alt+/ 选择registry，将 compiler.automake.allow.when.app.running勾选上。
5.运行时不想等的话，直接build=&amp;gt;build project </description>
    </item>
    
    <item>
      <title>VueX</title>
      <link>https://xxsvip.github.io/post/vuex/</link>
      <pubDate>Wed, 08 Apr 2020 14:59:48 +0800</pubDate>
      
      <guid>https://xxsvip.github.io/post/vuex/</guid>
      <description> 安装vuex：
vue i vuex  Vuex就是前端为了方便数据的操作而建立的一个“前端数据库”。
state State就是数据库。 state(vuex)约等于data(vue)
state一般被挂载到子组件的computed计算属性上，有利于state的值发生改变时及时响应给子组件。
mutations Mutations就是我们进行数据库操作的API，用来修改state。
mutations必须是同步函数。
actions Actions函数接收一个context参数。context与store实例有着相同的方法和属性。所以可以使用context.commit来提交一个mutation，或者可以通过context.state和context.getters来获取state和getters。
mutation通过store.commit触发，action通过store.dispatch来触发。
getters 类似于computed
核心概念  State&amp;mdash;-this.$store.state.xxx 取值 getter&amp;mdash;-this.$store.getters.xxx 取值 mutation&amp;mdash;-this.$store.commit(&amp;ldquo;xxx&amp;rdquo;) 赋值 action&amp;mdash;-this.$store.dispatch(&amp;ldquo;xxx&amp;rdquo;) 赋值  </description>
    </item>
    
    <item>
      <title>Vue入门</title>
      <link>https://xxsvip.github.io/post/vue%E5%85%A5%E9%97%A8/</link>
      <pubDate>Tue, 07 Apr 2020 16:41:58 +0800</pubDate>
      
      <guid>https://xxsvip.github.io/post/vue%E5%85%A5%E9%97%A8/</guid>
      <description>vue、angular、react要解决的问题是：数据驱动，避免手动的操作DOM。
vue特点：  更加轻量 20kb 渐进式框架（不需要学习完vue的所有知识便可以应用到系统中） 响应式的更新机制 学习成本低  vue指令 v-bind v-bind:id = &amp;quot;message&amp;quot;  此时id属性会根据后台message数据的值动态变换。上面指令可以简写为：
:id = &amp;quot;message&amp;quot;  v-if v-else v-show v-for  组件注册与使用 组件注册 注册组件时必须在new Vue之前。
Vue.component(&amp;quot;todo-item&amp;quot;,{ template: `&amp;lt;li&amp;gt; &amp;lt;span v-if=&amp;quot;!del&amp;quot;&amp;gt;{{title}}&amp;lt;/span&amp;gt; &amp;lt;span v-else style=&amp;quot;text-decoration:line-through&amp;quot;&amp;gt;{{title}}&amp;lt;/span&amp;gt; &amp;lt;button v-show=&amp;quot;!del&amp;quot;&amp;gt;删除&amp;lt;/button&amp;gt; &amp;lt;/li&amp;gt;`, props: { title: String, del: { type: Boolean, default: false } }, data: function(){ return {} }, methods: { } });	 组件使用 &amp;lt;todo-item v-for=&amp;quot;item in items&amp;quot; :title=&amp;quot;item.title&amp;quot; :del=&amp;quot;item.del&amp;quot; /&amp;gt;  组件注册2 Vue.</description>
    </item>
    
    <item>
      <title>Hugo搭建个人博客</title>
      <link>https://xxsvip.github.io/post/hugo/</link>
      <pubDate>Mon, 06 Apr 2020 11:43:05 +0800</pubDate>
      
      <guid>https://xxsvip.github.io/post/hugo/</guid>
      <description> hugo官网地址为：hugo
当前主题为：m10c
m10c主题相关：  修改avatar，在网站的static目录下放置avatar.jpg来替换默认的avatar。 可用icon图标在此：图标  每次提交步骤：  在项目根目录执行 hugo （会将修改内容生成pubic目录） cd public git commit -am &amp;lsquo;xxx&amp;rsquo; git push  </description>
    </item>
    
  </channel>
</rss>