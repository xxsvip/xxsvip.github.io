<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>小帅的技术小黑屋</title>
    <link>https://xxsvip.github.io/</link>
    <description>Recent content on 小帅的技术小黑屋</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 04 May 2020 18:14:42 +0800</lastBuildDate>
    
	<atom:link href="https://xxsvip.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Es6</title>
      <link>https://xxsvip.github.io/front/es6/</link>
      <pubDate>Mon, 04 May 2020 18:14:42 +0800</pubDate>
      
      <guid>https://xxsvip.github.io/front/es6/</guid>
      <description>简介 ECMAScript6.0是JavaScript语言的下一代标准，已经在2015年6月正式发布，并且从ECMAScript6开始，采用年号来做版本。
ECMAScript2016 ES7
ECMAScript2017 ES8
ECMAScript2018 ES9
ECMAScript2019 ES10
ECMAScript2020 ES11
ECMAScript是浏览器脚本语言的规范，JavaScript是规范的具体实现。
let var 声明的变量往往会越域
let 声明的变量有严格局部作用域
const声明常量（只读变量） 数组解构 let arr = [1,2,3] let [x,y,z] = arr console.log(x,y,z);  对象结构 const person = { name: &amp;quot;jack&amp;quot;, age: 21, language: [&#39;java&#39;,&#39;js&#39;,&#39;css&#39;] } let {name:abc,age,language} = person; console.log(abc,age,language);  字符串扩展 let str = &amp;quot;hello.vue&amp;quot;; console.log(str.startsWith(&amp;quot;hello&amp;quot;)); console.log(str.endsWith(&amp;quot;vue&amp;quot;)); console.log(str.includes(&amp;quot;e&amp;quot;)); console.log(str.includes(&amp;quot;hello&amp;quot;));  字符串模版 用反印号`来定义普通字符串或多行字符串
let ss = ` &amp;lt;div&amp;gt; &amp;lt;span&amp;gt;hello world&amp;lt;/span&amp;gt; &amp;lt;/div&amp;gt; ` console.</description>
    </item>
    
    <item>
      <title>Gateway</title>
      <link>https://xxsvip.github.io/springcloud/gateway/</link>
      <pubDate>Thu, 30 Apr 2020 16:44:30 +0800</pubDate>
      
      <guid>https://xxsvip.github.io/springcloud/gateway/</guid>
      <description>网关作为流量入口，常用功能包括路由转发、权限校验、流量控制等。而springcloud gateway作为SpringCloud官方推出的第二代网关框架，取代了Zuul网关。
 添加依赖
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-gateway&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;  在配置文件中配置gateway：
spring: cloud: nacos: discovery: server-addr: 127.0.0.1:8848 namespace: e6eabd07-f4f1-437e-bea6-f7fb5235c6df gateway: routes: - id: erp_route uri: http://localhost:7000 predicates: - Query=url,erp - id: oa_route uri: http://localhost:8000 predicates: - Query=url,oa - id: baidu_route uri: https://www.baidu.com predicates: - Query=url,baidu   </description>
    </item>
    
    <item>
      <title>Nacos配置中心</title>
      <link>https://xxsvip.github.io/springcloud/nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</link>
      <pubDate>Thu, 30 Apr 2020 11:04:02 +0800</pubDate>
      
      <guid>https://xxsvip.github.io/springcloud/nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</guid>
      <description>引入依赖：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-alibaba-nacos-config&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;  在resources目录下引入bootstrap.properties文件
spring.application.name=integration-erp spring.cloud.nacos.config.server-addr=127.0.0.1:8848 spring.cloud.nacos.config.file-extension=yaml spring.cloud.nacos.config.namespace=1ff6e0ce-d998-4b76-8b37-be9a6967c44a spring.cloud.nacos.config.group=dev   bootstrap.properties文件中的配置会优先于application.properties文件中的配置先进行读取。
 在nacos的web端进行配置，Data ID为
${prefix} - ${spring.profiles.active} . ${file-extension}   prefix默认为*spring.application.name*的值
spring.profiles.active即为当前环境对应的profile。注意，当spring.profiles.active为空时，对应的连接符-也将不存在，dataId的拼接格式变成${prefix}.${file-extension}；
file-extension为配置内容的数据格式，可以通过配置项spring.cloud.nacos.config.file-extension来配置。
通常，每个模块创建创建一个命名空间namespace，根据不同的环境创建分组group。
结合@Value注解和@RefreshScope动态改变参数值。</description>
    </item>
    
    <item>
      <title>Openfeign</title>
      <link>https://xxsvip.github.io/springcloud/openfeign/</link>
      <pubDate>Thu, 30 Apr 2020 09:51:38 +0800</pubDate>
      
      <guid>https://xxsvip.github.io/springcloud/openfeign/</guid>
      <description> 在调用方引入：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-openfeign&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;  定义接口，并加上注解@FeignClient(&amp;ldquo;远程服务项目名称&amp;rdquo;)，将远程接口的方法声明放到接口中，路径名为全路径名。
 开启远程调用：在springboot启动类中加入注解@EnableFeignClients(basePackages=&amp;ldquo;feign接口定义的包名&amp;rdquo;)
  </description>
    </item>
    
    <item>
      <title>Nacos注册中心</title>
      <link>https://xxsvip.github.io/springcloud/nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</link>
      <pubDate>Thu, 30 Apr 2020 08:50:43 +0800</pubDate>
      
      <guid>https://xxsvip.github.io/springcloud/nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</guid>
      <description> 引入dependencyManagement，后面引入Spring cloud alibaba相关的内容时不需要版本：
 &amp;lt;dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-alibaba-dependencies&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.1.0.RELEASE&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt; &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/dependencyManagement&amp;gt;   引入nacos discovery starter：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-alibaba-nacos-discovery&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;  在application.properties中配置nacos server地址（还可以指定namespace）：
spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848  在application.properties中配置nacos application name：
spring.application.name=xxx  在springboot的启动类中添加注解：
@EnableDiscoveryClient   Nacos Server  下载nacos server
 到bin目录下启动nacos：
sh startup.sh -m standalone  访问路径为：
127.0.0.1:8848/nacos  默认用户名密码都为 nacos
  </description>
    </item>
    
    <item>
      <title>Chrome端口</title>
      <link>https://xxsvip.github.io/dev/chrome%E7%AB%AF%E5%8F%A3/</link>
      <pubDate>Wed, 29 Apr 2020 10:20:39 +0800</pubDate>
      
      <guid>https://xxsvip.github.io/dev/chrome%E7%AB%AF%E5%8F%A3/</guid>
      <description>昨天运行项目，把端口设置为6666，访问时提示：
网址为 http://localhost:6666/ 的网页可能暂时无法连接，或者它已永久性地移动到了新网址。 ERR_UNSAFE_PORT  chrome默认有一些非安全端口，看最大的为6669（整数的还有6000也是非安全端口），所以以后尽量使用7000及以后的端口。</description>
    </item>
    
    <item>
      <title>Mysql</title>
      <link>https://xxsvip.github.io/docker/mysql/</link>
      <pubDate>Sun, 26 Apr 2020 11:48:05 +0800</pubDate>
      
      <guid>https://xxsvip.github.io/docker/mysql/</guid>
      <description>需要创建my.cnf文件，否则会以文件夹的形式创建，并在其中添加如下内容：
[mysqld] user=mysql character-set-server=utf8 default_authentication_plugin=mysql_native_password secure_file_priv=/var/lib/mysql expire_logs_days=7 sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION max_connections=1000 [client] default-character-set=utf8 [mysql] default-character-set=utf8  创建容器：
docker run -p 3306:3306 --name mysql --restart=always --privileged=true \ -v /Users/xingxiaoshuai/software/docker/mysql/log:/var/log/mysql \ -v /Users/xingxiaoshuai/software/docker/mysql/data:/var/lib/mysql \ -v /Users/xingxiaoshuai/software/docker/mysql/conf.d:/etc/mysql/cong.d \ -v /Users/xingxiaoshuai/software/docker/mysql/my.cnf:/etc/mysql/my.cnf \ -e MYSQL_ROOT_PASSWORD=root \ -d mysql  注意：启动mysql报如下错误，那是因为MYSQL新特性secure_file_priv对读写文件的影响。
修改my.cnf 在[mysqld]内加入secure_file_priv=/var/lib/mysql  </description>
    </item>
    
    <item>
      <title>连接器</title>
      <link>https://xxsvip.github.io/jonhon/%E8%BF%9E%E6%8E%A5%E5%99%A8/</link>
      <pubDate>Sat, 25 Apr 2020 09:48:29 +0800</pubDate>
      
      <guid>https://xxsvip.github.io/jonhon/%E8%BF%9E%E6%8E%A5%E5%99%A8/</guid>
      <description>插座：通常是两件式多接触件连接器上固定的或不动的那一半，也指通常安装在面板上并带有插孔的那一半连接器。
插孔：一种阴性接触件，能和阳性接触件插合，一般接在电路的带电侧。
插头（plug）：连接器的插合的两半之一，在未连接到另一半上时可自由活动，一般认为是连接器的阳性部分。
插针：一种阳性接触件，通常与插孔插配，一般连接在电路不带电的一侧。
接触电阻：装在连接器上的插针和插孔的最大允许电阻。
接触件 插针插孔的电连接是靠插针插孔的弹性接触来实现的，插针插孔的结构形式决定了接触的可靠性。
绞线式弹性插针（绞针） 由内层三根和外层七根弹性铜丝经过两次双向绞制而成。针与孔对接时外层的7根丝与插孔内壁形成7条螺旋线接触，保证了在各种环境条件下的接触可靠性。
优点：可实现微型化 缺点：工艺复杂。
线簧孔 插孔内有多根弹性丝，其接触原理与绞针式弹性插针相似；
优点：插拔力小。缺点：容易断丝、工艺复杂、无法实现微型化</description>
    </item>
    
    <item>
      <title>MES认识</title>
      <link>https://xxsvip.github.io/jonhon/mes%E8%AE%A4%E8%AF%86/</link>
      <pubDate>Fri, 24 Apr 2020 08:04:47 +0800</pubDate>
      
      <guid>https://xxsvip.github.io/jonhon/mes%E8%AE%A4%E8%AF%86/</guid>
      <description>战略层关注高阶数据（如完成率、变化趋势等）
中层管理关注更多的是实时数据（如计划进度、生产问题）
车间执行层更多关注的是相对静态的数据（装配BOM、工艺数据）
MES = 管理思想 + IT工具
利用IT手段的核心目的是在管理思想确定的情况下如何提高数据传输效率、降低工人强度与增强数据的可追溯性。比如由系统集成代替手工录入。
目前大厂商由于其自身成本压力会以产品化的思想，以产品灵活配置尽可能降低实施成本，再加上很多项目经验累积出一套可行的实施方法论，在实施过程中尽量避免各种耽搁时间的“坑”以降低成本。而小厂商的实施效果不好评价，只是大厂商遇到的成本问题，在小厂商只是缓解而不会根除。
所以如果长远来看，反而觉得围绕解决核心业务痛点的小系统（微服务）是个趋势。比如排产问题，产品类型、客户登记、订单交付时间等多维数据处理，如果仅仅依靠“人工智能”人为处理，工作强度大而且容易出错，但如果利用APS这种小工具则会大大减轻工作量。通此类比，可以将MES拆分为许多为车间执行层提供的小工具，如报表工具、质量检验工具等，各类小工具串联起来就会形成管理执行系统的MES系统。
正所谓专业的人做专业的事，这些小系统的发展因为需求范围比较窄，很容易做的精益求精，对提升效率、降低工作强度帮助巨大。由于MES本身需求难以界定，有些项目甚至将工艺、物流、成本核算等一系列需求添加到MES范围，造成同等成本下MES只能以串联为目的，而减轻了对各个模块对打磨，造成现场工人为了完成任务而使用MES。
综上，MES是接收ERP的生产计划，最后以产品交付结尾，中间穿插计划员、调度、车间工艺、检验员、操作工人等角色，业务穿插的过程中有许多核心业务。MES最佳的方式是由单点业务的提升，由单点到整个线条的串联。重点解决单点的效率问题，最终很自然的拓展到全部业务链。直接在整体上打破现有模式的MES实施模式是有高风险的。但是MES在上线过程中有许多企业的要求在里边，所以类似于这种单点业务串联成MES的实施方案更适合于没有政治要求的项目。</description>
    </item>
    
    <item>
      <title>配套</title>
      <link>https://xxsvip.github.io/jonhon/%E9%85%8D%E5%A5%97/</link>
      <pubDate>Thu, 23 Apr 2020 11:03:53 +0800</pubDate>
      
      <guid>https://xxsvip.github.io/jonhon/%E9%85%8D%E5%A5%97/</guid>
      <description>配套是针对工作订单进行的操作。
工作订单可能会拆分为多个车间订单。
配套在哪个系统进行，车间订单就在哪个系统生成。
目前38999车间想通过在MES中进行配套，所以接收的是ERP的工作订单，制造十部按原来的方式，在ERP中进行配套，所以接收的是ERP的车间订单。</description>
    </item>
    
    <item>
      <title>Redis</title>
      <link>https://xxsvip.github.io/docker/redis/</link>
      <pubDate>Mon, 20 Apr 2020 21:25:27 +0800</pubDate>
      
      <guid>https://xxsvip.github.io/docker/redis/</guid>
      <description>docker run -p 6379:6379 --name redis \ -v /Users/xingxiaoshuai/software/docker/redis:/data \ -v /Users/xingxiaoshuai/software/docker/redis/conf/redis.conf:/etc/redis/redis.conf \ -d redis redis-server /etc/redis/redis.conf  注意：上面的redis.conf文件要先创建了，否则会认为是一个目录
docker exec -it redis redis-cli  直接运行上面命令操作redis
默认redis是将数据存储在内存中的，在redis.conf文件中输入：
appendonly yes  这样会在redis目录下生成appendonly.aof文件，重启redis数据不会丢失。
docker update 容器名称 --restart=always  设置容器自启动。</description>
    </item>
    
    <item>
      <title>Modbus</title>
      <link>https://xxsvip.github.io/iot/modbus/</link>
      <pubDate>Fri, 17 Apr 2020 10:19:26 +0800</pubDate>
      
      <guid>https://xxsvip.github.io/iot/modbus/</guid>
      <description>数据模型 PLC地址 数据类型 读写方式 备注     Discretes Input寄存器1：离散输入 10001-19999 single bit read only This type of data can be provided by an I/O system.   Coils
寄存器0:线圈 00001-09999 single bit read-write this type of data can be alterable by an application program   Input Registers
寄存器3:输入寄存器 30001-39999 16bit word readonly this type of data can be provided by an I/O system.   Holding Registers</description>
    </item>
    
    <item>
      <title>DevTools热部署</title>
      <link>https://xxsvip.github.io/springboot/devtools%E7%83%AD%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Wed, 15 Apr 2020 17:07:07 +0800</pubDate>
      
      <guid>https://xxsvip.github.io/springboot/devtools%E7%83%AD%E9%83%A8%E7%BD%B2/</guid>
      <description> 1.pom文件引入依赖： &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-devtools&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;true&amp;lt;/scope&amp;gt; &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt; &amp;lt;/dependency&amp;gt;  2.pom插件设置： &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;fork&amp;gt;true&amp;lt;/fork&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt;  3.idea设置 到设置中 build,Execution,Deployment=&amp;gt;Compiler=&amp;gt;Build project automatically勾选上。
4.registry设置 cmd+shift+alt+/ 选择registry，将 compiler.automake.allow.when.app.running勾选上。
5.运行时不想等的话，直接build=&amp;gt;build project </description>
    </item>
    
    <item>
      <title>VueX</title>
      <link>https://xxsvip.github.io/post/vuex/</link>
      <pubDate>Wed, 08 Apr 2020 14:59:48 +0800</pubDate>
      
      <guid>https://xxsvip.github.io/post/vuex/</guid>
      <description> 安装vuex：
vue i vuex  Vuex就是前端为了方便数据的操作而建立的一个“前端数据库”。
state State就是数据库。 state(vuex)约等于data(vue)
state一般被挂载到子组件的computed计算属性上，有利于state的值发生改变时及时响应给子组件。
mutations Mutations就是我们进行数据库操作的API，用来修改state。
mutations必须是同步函数。
actions Actions函数接收一个context参数。context与store实例有着相同的方法和属性。所以可以使用context.commit来提交一个mutation，或者可以通过context.state和context.getters来获取state和getters。
mutation通过store.commit触发，action通过store.dispatch来触发。
getters 类似于computed
核心概念  State&amp;mdash;-this.$store.state.xxx 取值 getter&amp;mdash;-this.$store.getters.xxx 取值 mutation&amp;mdash;-this.$store.commit(&amp;ldquo;xxx&amp;rdquo;) 赋值 action&amp;mdash;-this.$store.dispatch(&amp;ldquo;xxx&amp;rdquo;) 赋值  </description>
    </item>
    
    <item>
      <title>Vue入门</title>
      <link>https://xxsvip.github.io/post/vue%E5%85%A5%E9%97%A8/</link>
      <pubDate>Tue, 07 Apr 2020 16:41:58 +0800</pubDate>
      
      <guid>https://xxsvip.github.io/post/vue%E5%85%A5%E9%97%A8/</guid>
      <description>vue、angular、react要解决的问题是：数据驱动，避免手动的操作DOM。
vue特点：  更加轻量 20kb 渐进式框架（不需要学习完vue的所有知识便可以应用到系统中） 响应式的更新机制 学习成本低  vue指令 v-bind v-bind:id = &amp;quot;message&amp;quot;  此时id属性会根据后台message数据的值动态变换。上面指令可以简写为：
:id = &amp;quot;message&amp;quot;  v-if v-else v-show v-for  组件注册与使用 组件注册 注册组件时必须在new Vue之前。
Vue.component(&amp;quot;todo-item&amp;quot;,{ template: `&amp;lt;li&amp;gt; &amp;lt;span v-if=&amp;quot;!del&amp;quot;&amp;gt;{{title}}&amp;lt;/span&amp;gt; &amp;lt;span v-else style=&amp;quot;text-decoration:line-through&amp;quot;&amp;gt;{{title}}&amp;lt;/span&amp;gt; &amp;lt;button v-show=&amp;quot;!del&amp;quot;&amp;gt;删除&amp;lt;/button&amp;gt; &amp;lt;/li&amp;gt;`, props: { title: String, del: { type: Boolean, default: false } }, data: function(){ return {} }, methods: { } });	 组件使用 &amp;lt;todo-item v-for=&amp;quot;item in items&amp;quot; :title=&amp;quot;item.title&amp;quot; :del=&amp;quot;item.del&amp;quot; /&amp;gt;  组件注册2 Vue.</description>
    </item>
    
    <item>
      <title>Hugo搭建个人博客</title>
      <link>https://xxsvip.github.io/post/hugo/</link>
      <pubDate>Mon, 06 Apr 2020 11:43:05 +0800</pubDate>
      
      <guid>https://xxsvip.github.io/post/hugo/</guid>
      <description> hugo官网地址为：hugo
当前主题为：m10c
m10c主题相关：  修改avatar，在网站的static目录下放置avatar.jpg来替换默认的avatar。 可用icon图标在此：图标  每次提交步骤：  在项目根目录执行 hugo （会将修改内容生成pubic目录） cd public git commit -am &amp;lsquo;xxx&amp;rsquo; git push  </description>
    </item>
    
  </channel>
</rss>